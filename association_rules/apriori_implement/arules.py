from itertools import combinations
from itemset import apriori_gen
from copy import deepcopy

class Rule:
    def __init__(
        self,
        antecedent: tuple,
        consequent: tuple,
        count: int,
        antecedent_count: int,
        consequent_count: int,
        transaction_count: int,
    ) -> None:
        """
        Params:
        -----
        antecedent: left hand side of the rule, eg: (A, B)--> (C); (A, B) is antecedent

        consequent: right-hand side of the rule

        count: the number of transaction containing antecedent and consequent

        antecedent_count: number of transaction containing antecedent

        consequent_count: number of transaction containing consequent

        transaction_count: total number of transactionss
        """
        self.antecedent = antecedent
        self.consequent = consequent
        self.count = count
        self.antecedent_count = antecedent_count
        self.consequent_count = consequent_count
        self.transaction_count = transaction_count

    @property
    def confidence(self):
        """
        X --> Y

        confidence is the probability of Y given X or P(Y|X)
        """
        try:
            return self.count / self.antecedent_count
        except ZeroDivisionError:
            return None
        except AttributeError:
            return None

    @property
    def support(self):
        """
        X --> Y

        support = transaction containing X and Y / total transaction
        """
        try:
            return self.count / self.transaction_count
        except ZeroDivisionError:
            return None
        except AttributeError:
            return None

    @property
    def lift(self):
        """
        The lift of a rule is the ratio of the observed support to the expected
        support if the lhs and rhs were independent.If X -> Y, then the lift is
        given by the fraction P(X and Y) / (P(X) * P(Y)).
        """
        try:
            observed_support = self.count / self.transaction_count
            antecedent_support = self.antecedent_count / self.transaction_count
            consequent_support = self.consequent_count / self.transaction_count
            expected_support = antecedent_support * consequent_support
            return observed_support / expected_support
        except ZeroDivisionError:
            return None
        except AttributeError:
            return None

    @property
    def conviction(self):
        """
        The conviction of a rule X -> Y is the ratio P(not Y) / P(not Y | X).
        It's the proportion of how often Y does not appear in the data to how
        often Y does not appear in the data, given X. If the ratio is large,
        then the confidence is large and Y appears often.
        """
        try:
            eps = 10e-10  # Avoid zero division
            prob_not_rhs = 1 - self.antecedent_count / self.transaction_count
            prob_not_rhs_given_lhs = 1 - self.confidence
            return prob_not_rhs / (prob_not_rhs_given_lhs + eps)
        except ZeroDivisionError:
            return None
        except AttributeError:
            return None

    def __eq__(self, __value: object) -> bool:
        """
        Equality check
        """
        return (set(self.antecedent) == set(__value.consequent)) and (
            set(self.consequent) == set(__value.consequent)
        )

    def __hash__(self) -> int:
        return hash(frozenset(self.antecedent + self.consequent))

    def __len__(self) -> int:
        return len(self.consequent) + len(self.antecedent)

    def __str__(self) -> str:
        return f"{self.antecedent} --> {self.consequent}"

    def __repr__(self) -> str:
        return f"{self.antecedent} --> {self.consequent}"


def generate_association_rules(
    frequent_itemsets: dict[int, dict[tuple, int]],
    min_confidence: float,
    transaction_num: int,
):
    association_rules = []
    """
    Function to generate association rule given frequent itemsets

    params:
        frequent_itemsets: 
        {
            'itemset_length': {
                (itemset): support_count,
            }
        }

        min_confidence: min confidence of rule to take

        transaction_num: total number of transaction, used to calculate confidence, etc...
    """

    def support(itemset: tuple, itemset_length: int) -> int:
        """
        Inner function to get the support of a itemset
        """

        return frequent_itemsets[itemset_length][itemset]

    # Generate rule from frequent itemsets:
    for k in frequent_itemsets:
        # No rules can be generated by 1-itemsets
        if k == 1:
            continue

        # for each k-itemset
        for itemset in frequent_itemsets[k]:
            H_1 = []

            for remove in combinations(itemset, 1):
                remaining = set(itemset).difference(set(remove))
                antecedent = tuple(sorted(remaining))
                candidate_rule = Rule(
                    antecedent=antecedent,
                    consequent=remove,
                    count=support(itemset, len(itemset)),
                    antecedent_count=support(antecedent, len(itemset) - 1),
                    consequent_count=support(remove, 1),
                    transaction_count=transaction_num,
                )

                if candidate_rule.confidence >= min_confidence:
                    association_rules.append(candidate_rule)
                    H_1.append(remove)

            if not H_1:
                continue
            else:
                k_length_consequent_rules = ap_genrules(
                    itemset, H_1, min_confidence, transaction_num, frequent_itemsets, rules=[]
                )
                association_rules.extend(k_length_consequent_rules)

    return association_rules


def ap_genrules(
    itemset: tuple,
    H_m: list[tuple],
    min_confidence: float,
    transaction_num: int,
    frequent_itemsets: dict[int, dict[tuple, int]],
    rules: list[Rule] = [],
):
    def support(itemset: tuple, itemset_length: int) -> int:
        """
        Inner function to get the support of a itemset
        """
        return frequent_itemsets[itemset_length][itemset]

    if len(itemset) <= (len(H_m[0]) + 1):
        return rules

    # generate H_m+1 from H_m
    H_m = list(apriori_gen(H_m))
    H_m_cpy = deepcopy(H_m)

    for h_m in H_m:
        ante = tuple(sorted(set(itemset).difference(set(h_m))))
        conf = support(itemset, len(itemset)) / support(ante, len(ante))
        if conf >= min_confidence:
            rules.append(
                Rule(
                    antecedent=ante,
                    consequent=h_m,
                    count=support(itemset, len(itemset)),
                    antecedent_count=support(ante, len(ante)),
                    consequent_count=support(h_m, len(h_m)),
                    transaction_count=transaction_num,
                )
            )
        else:
            H_m_cpy.remove(h_m)

    if not H_m_cpy:
        return rules
    else:
        return ap_genrules(
            itemset, H_m_cpy, min_confidence, transaction_num, frequent_itemsets, rules
        )
